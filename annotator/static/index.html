<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rally Annotator</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: system-ui, sans-serif; background: #1a1a1a; color: #fff; padding: 20px; }
        h1 { margin-bottom: 20px; }
        .container { max-width: 1600px; margin: 0 auto; }
        .main-layout { display: flex; gap: 16px; }
        .main-layout .left-panel { flex: 1; min-width: 0; }
        .main-layout .right-panel { width: 400px; flex-shrink: 0; }
        .panel { background: #2a2a2a; border-radius: 8px; padding: 16px; margin-bottom: 16px; }
        select, button, input { padding: 8px 16px; border-radius: 4px; border: none; font-size: 14px; }
        select { background: #3a3a3a; color: #fff; min-width: 200px; }
        button { background: #4a9eff; color: #fff; cursor: pointer; }
        button:hover { background: #3a8eef; }
        button:disabled { background: #555; cursor: not-allowed; }
        input { background: #3a3a3a; color: #fff; }
        video { width: 100%; max-height: 500px; background: #000; border-radius: 8px; }

        .controls { display: flex; gap: 10px; align-items: center; margin-top: 12px; flex-wrap: wrap; }
        .time-display { font-family: monospace; font-size: 16px; background: #3a3a3a; padding: 8px 12px; border-radius: 4px; }

        /* Timeline styles */
        .timeline-container { margin-top: 16px; }
        .timeline {
            position: relative;
            height: 40px;
            background: #3a3a3a;
            border-radius: 4px;
            cursor: pointer;
            overflow: hidden;
        }
        .timeline-segment {
            position: absolute;
            height: 100%;
            opacity: 0.8;
        }
        .timeline-segment.rally { background: #27ae60; }
        .timeline-segment.non-rally { background: #7f8c8d; }
        .timeline-segment.selected {
            outline: 3px solid #f1c40f;
            z-index: 10;
        }
        .timeline-playhead {
            position: absolute;
            width: 2px;
            height: 100%;
            background: #e74c3c;
            z-index: 20;
            pointer-events: none;
        }
        .timeline-pending {
            position: absolute;
            height: 100%;
            background: rgba(241, 196, 15, 0.5);
            border: 2px dashed #f1c40f;
            z-index: 5;
        }
        .timeline-times {
            display: flex;
            justify-content: space-between;
            font-family: monospace;
            font-size: 12px;
            color: #888;
            margin-top: 4px;
        }

        /* Annotation list */
        .annotations { margin-top: 16px; max-height: 500px; overflow-y: auto; }
        .annotation {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: #3a3a3a;
            border-radius: 4px;
            margin-bottom: 8px;
            cursor: pointer;
        }
        .annotation:hover { background: #4a4a4a; }
        .annotation.selected { background: #4a6a4a; outline: 2px solid #27ae60; }
        .annotation .index {
            width: 30px;
            text-align: center;
            font-weight: bold;
            color: #888;
        }
        .annotation .label-btn {
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }
        .annotation .label-btn.rally { background: #27ae60; }
        .annotation .label-btn.non-rally { background: #7f8c8d; }
        .annotation .times {
            font-family: monospace;
            flex: 1;
        }
        .annotation input[type="text"] {
            width: 80px;
            padding: 4px 8px;
        }

        .btn-danger { background: #e74c3c; }
        .btn-danger:hover { background: #c0392b; }
        .btn-success { background: #27ae60; }
        .btn-success:hover { background: #1e8449; }
        .btn-secondary { background: #7f8c8d; }
        .btn-secondary:hover { background: #6c7a7b; }

        .status { margin-top: 12px; padding: 12px; border-radius: 4px; }
        .status.success { background: #1e4620; }
        .status.error { background: #4a1515; }
        .empty { color: #888; font-style: italic; }

        .shortcuts {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 8px;
            margin-top: 12px;
            font-size: 13px;
        }
        .shortcuts kbd {
            background: #4a4a4a;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
        }

        h3 { margin-bottom: 12px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Rally Annotator</h1>

        <div class="panel">
            <label>Detection Results: </label>
            <select id="resultsSelect">
                <option value="">-- Select JSON file --</option>
            </select>
            <button id="loadBtn">Load</button>
            <span id="loadStatus" style="margin-left: 12px; color: #888;"></span>
        </div>

        <div class="main-layout">
            <div class="left-panel">
                <div class="panel">
                    <video id="player" controls></video>

                    <div class="timeline-container">
                        <div class="timeline" id="timeline">
                            <div class="timeline-playhead" id="playhead"></div>
                        </div>
                        <div class="timeline-times">
                            <span>00:00</span>
                            <span id="durationDisplay">00:00</span>
                        </div>
                    </div>

                    <div class="controls">
                        <span class="time-display" id="currentTime">00:00.000</span>
                        <button id="markStart">[  Mark Start</button>
                        <button id="markEnd">]  Mark End</button>
                        <button id="addAnnotation" class="btn-success">Enter  Add Rally</button>
                    </div>
                    <div id="pendingAnnotation" style="margin-top: 10px; color: #f1c40f;"></div>
                </div>
            </div>

            <div class="right-panel">
                <div class="panel">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <h3>Annotations</h3>
                        <button id="addNonRally" class="btn-secondary">Add Non-Rally</button>
                    </div>
                    <div id="annotationList" class="annotations">
                        <p class="empty">No annotations yet. Load a detection result to start.</p>
                    </div>
                    <div style="margin-top: 12px; display: flex; gap: 10px;">
                        <button id="saveBtn" class="btn-success">Save Annotations</button>
                        <button id="clearBtn" class="btn-danger">Clear All</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="panel">
            <h3>Keyboard Shortcuts</h3>
            <div class="shortcuts">
                <div><kbd>Space</kbd> Play/Pause</div>
                <div><kbd>←</kbd> <kbd>→</kbd> Skip ±5s</div>
                <div><kbd>[</kbd> Mark Start</div>
                <div><kbd>]</kbd> Mark End</div>
                <div><kbd>Enter</kbd> Add Rally</div>
                <div><kbd>J</kbd> Jump to Selected</div>
                <div><kbd>Delete</kbd> Delete Selected</div>
                <div><kbd>T</kbd> Toggle Label</div>
            </div>
        </div>

        <div id="statusArea"></div>
    </div>

    <script>
        // DOM elements
        const resultsSelect = document.getElementById('resultsSelect');
        const loadBtn = document.getElementById('loadBtn');
        const loadStatus = document.getElementById('loadStatus');
        const player = document.getElementById('player');
        const timeline = document.getElementById('timeline');
        const playhead = document.getElementById('playhead');
        const currentTimeDisplay = document.getElementById('currentTime');
        const durationDisplay = document.getElementById('durationDisplay');
        const markStartBtn = document.getElementById('markStart');
        const markEndBtn = document.getElementById('markEnd');
        const addAnnotationBtn = document.getElementById('addAnnotation');
        const addNonRallyBtn = document.getElementById('addNonRally');
        const pendingAnnotationDiv = document.getElementById('pendingAnnotation');
        const annotationList = document.getElementById('annotationList');
        const saveBtn = document.getElementById('saveBtn');
        const clearBtn = document.getElementById('clearBtn');
        const statusArea = document.getElementById('statusArea');

        // State
        let annotations = [];
        let selectedIndex = -1;
        let pendingStart = null;
        let pendingEnd = null;
        let currentVideoPath = '';
        let videoDuration = 0;
        let playUntil = null;  // Auto-pause at this time

        // Utility functions
        function formatTimeShort(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
        }

        function parseTimeInput(timeStr) {
            const parts = timeStr.split(':');
            if (parts.length === 2) {
                const mins = parseInt(parts[0], 10) || 0;
                const secs = parseFloat(parts[1]) || 0;
                return mins * 60 + secs;
            }
            return parseFloat(timeStr) || 0;
        }

        // Load results list
        async function loadResultsList() {
            try {
                const res = await fetch('/api/results');
                const results = await res.json();
                results.forEach(name => {
                    const opt = document.createElement('option');
                    opt.value = name;
                    opt.textContent = name;
                    resultsSelect.appendChild(opt);
                });
            } catch (err) {
                console.error('Failed to load results:', err);
            }
        }

        // Merge adjacent gameplay clips into rally annotations
        // Gameplay = has_volleyball AND full_court shot
        // Non-gameplay clips act as rally separators
        function mergeClipsToRallies(results, gapThreshold = 2.0) {
            if (results.length === 0) return [];

            const sorted = [...results].sort((a, b) => a.start_time - b.start_time);

            const rallies = [];
            let currentRally = null;

            for (const clip of sorted) {
                // Gameplay: has volleyball activity AND full court view
                const isGameplay = clip.has_volleyball && clip.shot_type === 'full_court';

                if (isGameplay) {
                    if (currentRally === null) {
                        currentRally = {
                            start: clip.start_time,
                            end: clip.end_time,
                            label: 'rally'
                        };
                    } else if (clip.start_time - currentRally.end <= gapThreshold) {
                        currentRally.end = Math.max(currentRally.end, clip.end_time);
                    } else {
                        rallies.push({...currentRally});
                        currentRally = {
                            start: clip.start_time,
                            end: clip.end_time,
                            label: 'rally'
                        };
                    }
                } else {
                    // close_up - end current rally
                    if (currentRally !== null) {
                        rallies.push({...currentRally});
                        currentRally = null;
                    }
                }
            }

            if (currentRally !== null) {
                rallies.push(currentRally);
            }

            return rallies;
        }

        // Load detection results
        loadBtn.addEventListener('click', async () => {
            if (!resultsSelect.value) {
                alert('Please select a results file');
                return;
            }

            loadStatus.textContent = 'Loading...';

            try {
                const res = await fetch(`/api/results/${encodeURIComponent(resultsSelect.value)}`);
                const data = await res.json();

                // Set video
                currentVideoPath = data.video;
                player.src = `/api/video/${encodeURIComponent(data.video)}`;

                // Merge clips into rallies
                annotations = mergeClipsToRallies(data.results);
                selectedIndex = -1;
                pendingStart = null;
                pendingEnd = null;

                loadStatus.textContent = `Loaded ${annotations.length} rallies from ${data.results.length} clips`;

                player.addEventListener('loadedmetadata', function onMeta() {
                    videoDuration = player.duration;
                    durationDisplay.textContent = formatTimeShort(videoDuration);
                    renderTimeline();
                    renderAnnotations();
                    player.removeEventListener('loadedmetadata', onMeta);
                });

            } catch (err) {
                loadStatus.textContent = `Error: ${err.message}`;
            }
        });

        // Video time update
        player.addEventListener('timeupdate', () => {
            currentTimeDisplay.textContent = formatTimeShort(player.currentTime);
            updatePlayhead();

            // Auto-pause when reaching playUntil time
            if (playUntil !== null && player.currentTime >= playUntil) {
                player.pause();
                playUntil = null;
            }
        });

        function updatePlayhead() {
            if (videoDuration > 0) {
                const percent = (player.currentTime / videoDuration) * 100;
                playhead.style.left = `${percent}%`;
            }
        }

        // Timeline click
        timeline.addEventListener('click', (e) => {
            const rect = timeline.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const percent = x / rect.width;
            player.currentTime = percent * videoDuration;
        });

        // Mark start/end
        markStartBtn.addEventListener('click', () => {
            pendingStart = player.currentTime;
            updatePendingDisplay();
            renderTimeline();
        });

        markEndBtn.addEventListener('click', () => {
            pendingEnd = player.currentTime;
            updatePendingDisplay();
            renderTimeline();
        });

        function updatePendingDisplay() {
            if (pendingStart !== null || pendingEnd !== null) {
                const startStr = pendingStart !== null ? formatTimeShort(pendingStart) : '---';
                const endStr = pendingEnd !== null ? formatTimeShort(pendingEnd) : '---';
                pendingAnnotationDiv.textContent = `Pending: ${startStr} → ${endStr}`;
            } else {
                pendingAnnotationDiv.textContent = '';
            }
        }

        // Add annotation
        function addAnnotationWithLabel(label) {
            if (pendingStart === null || pendingEnd === null) {
                alert('Please mark both start and end times');
                return;
            }
            if (pendingEnd <= pendingStart) {
                alert('End time must be after start time');
                return;
            }

            annotations.push({
                start: pendingStart,
                end: pendingEnd,
                label: label
            });

            // Sort by start time
            annotations.sort((a, b) => a.start - b.start);

            pendingStart = null;
            pendingEnd = null;
            updatePendingDisplay();
            renderTimeline();
            renderAnnotations();
        }

        addAnnotationBtn.addEventListener('click', () => addAnnotationWithLabel('rally'));
        addNonRallyBtn.addEventListener('click', () => addAnnotationWithLabel('non-rally'));

        // Render timeline
        function renderTimeline() {
            // Clear segments
            timeline.querySelectorAll('.timeline-segment, .timeline-pending').forEach(el => el.remove());

            // Render annotations
            annotations.forEach((ann, i) => {
                const left = (ann.start / videoDuration) * 100;
                const width = ((ann.end - ann.start) / videoDuration) * 100;

                const seg = document.createElement('div');
                seg.className = `timeline-segment ${ann.label}`;
                if (i === selectedIndex) seg.classList.add('selected');
                seg.style.left = `${left}%`;
                seg.style.width = `${width}%`;
                seg.title = `${ann.label}: ${formatTimeShort(ann.start)} → ${formatTimeShort(ann.end)}`;
                seg.addEventListener('click', (e) => {
                    e.stopPropagation();
                    selectAnnotation(i);
                    player.currentTime = ann.start;
                });
                timeline.appendChild(seg);
            });

            // Render pending
            if (pendingStart !== null || pendingEnd !== null) {
                const start = pendingStart ?? 0;
                const end = pendingEnd ?? videoDuration;
                if (end > start) {
                    const left = (start / videoDuration) * 100;
                    const width = ((end - start) / videoDuration) * 100;

                    const pending = document.createElement('div');
                    pending.className = 'timeline-pending';
                    pending.style.left = `${left}%`;
                    pending.style.width = `${width}%`;
                    timeline.appendChild(pending);
                }
            }
        }

        // Render annotation list
        function renderAnnotations() {
            if (annotations.length === 0) {
                annotationList.innerHTML = '<p class="empty">No annotations yet. Load a detection result to start.</p>';
                return;
            }

            annotationList.innerHTML = annotations.map((ann, i) => `
                <div class="annotation${i === selectedIndex ? ' selected' : ''}" data-index="${i}">
                    <span class="index">${i + 1}</span>
                    <button class="label-btn ${ann.label}" onclick="toggleLabel(${i})">${ann.label}</button>
                    <span class="times">
                        <input type="text" value="${formatTimeShort(ann.start)}"
                               onchange="updateAnnotation(${i}, 'start', parseTimeInput(this.value))" onclick="event.stopPropagation()">
                        →
                        <input type="text" value="${formatTimeShort(ann.end)}"
                               onchange="updateAnnotation(${i}, 'end', parseTimeInput(this.value))" onclick="event.stopPropagation()">
                    </span>
                    <button onclick="jumpToAnnotation(${i}); event.stopPropagation();">Jump</button>
                    <button class="btn-danger" onclick="deleteAnnotation(${i}); event.stopPropagation();">Del</button>
                </div>
            `).join('');

            // Add click handlers for selection and playback
            annotationList.querySelectorAll('.annotation').forEach(el => {
                el.addEventListener('click', () => {
                    playAnnotation(parseInt(el.dataset.index));
                });
            });
        }

        function selectAnnotation(index) {
            selectedIndex = index;
            renderTimeline();
            renderAnnotations();
        }

        function playAnnotation(index) {
            selectAnnotation(index);
            const ann = annotations[index];
            player.currentTime = ann.start;
            playUntil = ann.end;
            player.play();
        }

        window.toggleLabel = function(index) {
            annotations[index].label = annotations[index].label === 'rally' ? 'non-rally' : 'rally';
            renderTimeline();
            renderAnnotations();
        };

        window.updateAnnotation = function(index, field, value) {
            annotations[index][field] = value;
            annotations.sort((a, b) => a.start - b.start);
            renderTimeline();
            renderAnnotations();
        };

        window.jumpToAnnotation = function(index) {
            selectAnnotation(index);
            player.currentTime = annotations[index].start;
        };

        window.deleteAnnotation = function(index) {
            annotations.splice(index, 1);
            if (selectedIndex >= annotations.length) {
                selectedIndex = annotations.length - 1;
            }
            if (selectedIndex < 0) selectedIndex = -1;
            renderTimeline();
            renderAnnotations();
        };

        // Save annotations
        saveBtn.addEventListener('click', async () => {
            if (!currentVideoPath) {
                alert('No video loaded');
                return;
            }

            // Filter to only rally annotations for TAD training
            const rallyAnnotations = annotations.filter(a => a.label === 'rally');

            saveBtn.disabled = true;
            saveBtn.textContent = 'Saving...';

            try {
                const res = await fetch('/api/annotations', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        video: currentVideoPath,
                        duration: videoDuration,
                        annotations: rallyAnnotations
                    })
                });
                const result = await res.json();
                statusArea.innerHTML = `<div class="status success">Saved ${result.count} rally annotations to: ${result.saved}</div>`;
            } catch (err) {
                statusArea.innerHTML = `<div class="status error">Error: ${err.message}</div>`;
            } finally {
                saveBtn.disabled = false;
                saveBtn.textContent = 'Save Annotations';
            }
        });

        // Clear all
        clearBtn.addEventListener('click', () => {
            if (confirm('Clear all annotations?')) {
                annotations = [];
                selectedIndex = -1;
                renderTimeline();
                renderAnnotations();
            }
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Ignore if typing in input
            if (e.target.tagName === 'INPUT') return;

            const skip = 5;

            switch (e.key) {
                case ' ':
                    e.preventDefault();
                    if (player.paused) player.play();
                    else player.pause();
                    break;
                case 'ArrowLeft':
                    player.currentTime = Math.max(0, player.currentTime - skip);
                    break;
                case 'ArrowRight':
                    player.currentTime = Math.min(videoDuration, player.currentTime + skip);
                    break;
                case '[':
                    pendingStart = player.currentTime;
                    updatePendingDisplay();
                    renderTimeline();
                    break;
                case ']':
                    pendingEnd = player.currentTime;
                    updatePendingDisplay();
                    renderTimeline();
                    break;
                case 'Enter':
                    addAnnotationWithLabel('rally');
                    break;
                case 'j':
                case 'J':
                    if (selectedIndex >= 0) {
                        player.currentTime = annotations[selectedIndex].start;
                    }
                    break;
                case 'Delete':
                case 'Backspace':
                    if (selectedIndex >= 0) {
                        deleteAnnotation(selectedIndex);
                    }
                    break;
                case 't':
                case 'T':
                    if (selectedIndex >= 0) {
                        toggleLabel(selectedIndex);
                    }
                    break;
            }
        });

        // Init
        loadResultsList();
    </script>
</body>
</html>
